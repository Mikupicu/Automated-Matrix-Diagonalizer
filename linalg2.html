<!DOCTYPE html>
<html>
<head>
  <title>Diagonalizable Matrix Checker</title>
  <style>
            body { font-family: Arial; padding: 20px; }
            input { width: 60px; }
            table { border-collapse: collapse; margin-bottom: 10px; }
            td { border: 1px solid #ccc; padding: 4px; }
            button { margin: 5px; padding: 6px 12px; }
            pre { background: #f4f4f4; padding: 10px; }
            #matrixArea { display: flex; justify-content: center; }
    </style>
</head>
<body>
<h2>Diagonalizable Matrix Checker</h2>
<label>Matrix size (2 to 5): </label>
<div id="sizeBtns">
  <button onclick="setN(2)">2×2</button>
  <button onclick="setN(3)">3×3</button>
  <button onclick="setN(4)">4×4</button>
  <button onclick="setN(5)">5×5</button>
</div>
<input type="hidden" id="n" value="">
<button onclick="makeMatrix()">Input Matrix</button>
<button onclick="randomFill()">Generate Random Values</button>
<label style="margin-left:8px;"><input type="checkbox" id="decimals"> Generate decimals</label>
<div id="matrixArea"></div>
<button onclick="confirmInput()">Enter</button> <button onclick="clearAll()">Clear</button>

<pre id="output"></pre>
<h3>Matrix P (Eigenvectors)</h3>
<pre id="Pout"></pre>
<h3>Matrix D (Diagonal)</h3>
<pre id="Dout"></pre>

<script>
let A = [];

function setN(val){ document.getElementById('n').value = val; }

  //error handling to not allow a default matrix before calculating
function makeMatrix(){
  let n = parseInt(document.getElementById('n').value,10);
  const out = document.getElementById('output');
  if(!n || n < 2 || n > 5){
    out.textContent = 'Error: Please select a matrix size (2×2 to 5×5) first.';
    return;
  }

  // (guarded above)
  // n already validated

  let html = '<table>';
  for(let i=0;i<n;i++){
    html += '<tr>';
    for(let j=0;j<n;j++){
      html += `<td><input type="text" id="a${i}${j}" value="0" inputmode="decimal" oninput="this.value=this.value.replace(/[^0-9+\-.]/g,'')"></td>`;
    }
    html += '</tr>';
  }
  html += '</table>';
  document.getElementById('matrixArea').innerHTML = html;
}

//error handling for no chosen matrix size yet
function confirmInput(){
  let n = +document.getElementById('n').value;
  A = [];
  for(let i=0;i<n;i++){
    let row=[];
    for(let j=0;j<n;j++){
      const raw = document.getElementById(`a${i}${j}`).value.trim();
      if(!/^[-+]?\d*(?:\.\d+)?$/.test(raw) || raw===''){
        document.getElementById('output').textContent = 'Error: Only whole or decimal numbers are allowed.';
        return;
      }
      row.push(parseFloat(raw));
    }
    A.push(row);
  }
  analyze();
}

function clone(M){ return M.map(r=>r.slice()); }

function multiply(A,B){
  let n=A.length, m=B[0].length, p=B.length;
  let C=Array.from({length:n},()=>Array(m).fill(0));
  for(let i=0;i<n;i++)for(let j=0;j<m;j++)for(let k=0;k<p;k++)C[i][j]+=A[i][k]*B[k][j];
  return C;
}

function identity(n){ return Array.from({length:n},(_,i)=>Array.from({length:n},(_,j)=>i===j?1:0)); }

function transpose(M){ return M[0].map((_,j)=>M.map(r=>r[j])); }

function qrDecomp(A){
  let n=A.length;
  let Q=identity(n), R=clone(A);
  for(let j=0;j<n;j++){
    let v = R.map(r=>r[j]);
    for(let i=0;i<j;i++){
      let qi = Q.map(r=>r[i]);
      let dot = qi.reduce((s,x,k)=>s+x*v[k],0);
      for(let k=0;k<n;k++) v[k]-=dot*qi[k];
    }
    let norm = Math.sqrt(v.reduce((s,x)=>s+x*x,0));
    if(norm===0) continue;
    for(let k=0;k<n;k++) Q[k][j]=v[k]/norm;
  }
  R = multiply(transpose(Q),A);
  return {Q,R};
}

function eigenvalues(A,it=1024){
  let M=clone(A);
  for(let k=0;k<it;k++){
    let {Q,R}=qrDecomp(M);
    M = multiply(R,Q);
  }
  return M.map((r,i)=>r[i]);
}

// Solve (A - λI)v = 0 using Gaussian elimination (basic)
function eigenvectorFromLambda(A, lambda){
  const n=A.length;
  // Build M = A - λI
  let M=A.map((r,i)=>r.map((x,j)=>x-(i===j?lambda:0)));
  // Augment with zeros for homogeneous system
  // RREF
  let row=0, col=0;
  while(row<n && col<n){
    // find pivot
    let sel=row;
    for(let i=row;i<n;i++) if(Math.abs(M[i][col])>Math.abs(M[sel][col])) sel=i;
    if(Math.abs(M[sel][col])<1e-8){ col++; continue; }
    // swap
    [M[row],M[sel]]=[M[sel],M[row]];
    // normalize
    let div=M[row][col];
    for(let j=col;j<n;j++) M[row][j]/=div;
    // eliminate
    for(let i=0;i<n;i++){
      if(i!==row){
        let factor=M[i][col];
        for(let j=col;j<n;j++) M[i][j]-=factor*M[row][j];
      }
    }
    row++; col++;
  }
  // pick a free variable = 1
  let v=Array(n).fill(0);
  let pivotCols=new Set();
  for(let i=0;i<n;i++){
    let j=M[i].findIndex(x=>Math.abs(x)>1e-8);
    if(j>=0) pivotCols.add(j);
  }
  let freeCol=0; while(pivotCols.has(freeCol)&&freeCol<n) freeCol++;
  if(freeCol<n) v[freeCol]=1; else v[n-1]=1;
  // back substitute
  for(let i=n-1;i>=0;i--){
    let j=M[i].findIndex(x=>Math.abs(x)>1e-8);
    if(j>=0){
      let sum=0;
      for(let k=j+1;k<n;k++) sum+=M[i][k]*v[k];
      v[j]=-sum/M[i][j];
    }
  }
  return v;
}

function analyze(){
  let out=document.getElementById('output');
  let n=A.length;
  if(n===0){ out.textContent='Please enter and confirm a matrix.'; return; }

  let eig = eigenvalues(A).map(x=>Math.round(x*1000)/1000);
  out.textContent='Eigenvalues: '+eig.join(', ')+'\n';

  let unique = [...new Set(eig)];
  let diagonalizable = (unique.length===n); //We need to check for linearly independent eigenvector columns rather than unique eigenvalues
  if(!diagonalizable){
    document.getElementById('Pout').textContent='';
    document.getElementById('Dout').textContent='';
    out.textContent='Error: Matrix is NOT diagonalizable.';
    return;
  }
  if(diagonalizable){
    out.textContent+='All eigenvalues distinct → Diagonalizable.\n';
  }else{
    out.textContent+='Repeated eigenvalues detected → May not be diagonalizable.\n';
  }

  // Build D
  let D = Array.from({length:n},(_,i)=>Array.from({length:n},(_,j)=> i===j?eig[i]:0));
  let Dtext = D.map(r=>r.join('  ')).join('\n');
  document.getElementById('Dout').textContent = Dtext;

  // Build P using eigenvectors (only if distinct eigenvalues)
  if(diagonalizable){
    let P = [];
    for(let i=0;i<n;i++){
      let v = eigenvectorFromLambda(A, eig[i]);
      P.push(v);
    }
    // columns = eigenvectors
    let PT = transpose(P); // rows to columns
    let Ptext = PT.map(r=>r.map(x=>Math.round(x*1000)/1000).join('  ')).join('\n');
    document.getElementById('Pout').textContent = Ptext;
  }else{
    document.getElementById('Pout').textContent = 'Cannot form full P because eigenvalues are not all distinct.';
  }
}

function clearAll(){
  A = [];
  document.getElementById('matrixArea').innerHTML='';
  document.getElementById('output').textContent='';
  document.getElementById('Pout').textContent='';
  document.getElementById('Dout').textContent='';
}

// Random integer from -9 to 9
// Random integer from -9 to 9
function randInt(){ return Math.floor(Math.random()*19)-9; }

// Random decimal from -9.9 to 9.9 (1 decimal place)
function randDec(){ return (Math.random()*19-9.5).toFixed(1); }

// Fill matrix with random positive & negative values
// Fill matrix with random values based on checkbox
function randomFill(){
  let n = +document.getElementById('n').value;
  const decBox = document.getElementById('decimals');
  const useDecimals = decBox && decBox.checked;
  // If grid not created yet, create it first
  if(!document.getElementById('a00')) makeMatrix();
  for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
      const el = document.getElementById(`a${i}${j}`);
      if(!el) continue;
      el.value = useDecimals ? randDec() : randInt();
    }
  }
}
</script>
</body>
</html>

